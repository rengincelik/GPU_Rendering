
#pragma kernel CSMain

RWStructuredBuffer<float4> PosScaleBuffer; // xyz = position, w = scale
RWStructuredBuffer<float4> ColorBuffer;    // rgba
RWTexture2D<float4> gradientTex;           // CPU’dan gönderilecek

cbuffer Params
{
    float2 areaSize;
    float width;
    float height;
    float positionNoise;
    float scaleNoise;
    uint grassCount;
}

// Better random function
float rand(float2 seed)
{
    return frac(sin(dot(seed, float2(12.9898, 78.233))) * 43758.5453);
}

[numthreads(64,1,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    if (index >= grassCount) return;

    // Grid-based positioning
    uint gridSize = (uint)ceil(sqrt((float)grassCount));
    float cellSizeX = areaSize.x / gridSize;
    float cellSizeZ = areaSize.y / gridSize;

    uint x = index % gridSize;
    uint z = index / gridSize;

    // Add noise to position
    float2 noiseSeed = float2(index, index * 1.618);
    float noiseX = (rand(noiseSeed) - 0.5) * positionNoise;
    float noiseZ = (rand(noiseSeed * 2.0) - 0.5) * positionNoise;

    float posX = (x + 0.5) * cellSizeX - areaSize.x * 0.5 + noiseX;
    float posZ = (z + 0.5) * cellSizeZ - areaSize.y * 0.5 + noiseZ;
    float posY = 0;

    // Scale with noise
    float scale = 1.0 + (rand(noiseSeed * 3.0) - 0.5) * scaleNoise;
    scale = clamp(scale, 0.1, 2.0);

    // Color from gradient
    float colorT = rand(noiseSeed * 5.0);
    uint widthTex, heightTex;
    gradientTex.GetDimensions(widthTex, heightTex);
    uint xIndex = (uint)(colorT * (widthTex - 1));
    float4 color = gradientTex[int2(xIndex,0)];

    // Write to buffers
    PosScaleBuffer[index] = float4(posX, posY, posZ, scale);
    ColorBuffer[index] = color;
}
