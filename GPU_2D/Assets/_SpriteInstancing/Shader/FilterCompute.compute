

// // #pragma kernel CSMain

// // struct InstanceData
// // {
// //     float3 position;
// //     int active;
// // };

// // // Input/Output buffers
// // RWStructuredBuffer<InstanceData> _ComputeInstanceDataBuffer;
// // AppendStructuredBuffer<InstanceData> activeBuffer;
// // AppendStructuredBuffer<InstanceData> filteredBuffer;

// // // Shader parameters
// // float3 playerPos;
// // float radius;
// // uint maxInstances;

// // // Optimized with better thread group size
// // [numthreads(64, 1, 1)]
// // void CSMain(uint3 id : SV_DispatchThreadID)
// // {
// //     uint idx = id.x;
// //     if (idx >= maxInstances) return;

// //     InstanceData data = _ComputeInstanceDataBuffer[idx];
    
// //     // Early exit if already inactive
// //     if (data.active == 0)
// //         return;

// //     // Calculate distance using squared distance for performance
// //     float3 diff = data.position - playerPos;
// //     float distSq = dot(diff, diff);
// //     float radiusSq = radius * radius;
    
// //     // Check if within erase radius
// //     if (distSq < radiusSq)
// //     {
// //         // Deactivate instance
// //         data.active = 0;
// //         _ComputeInstanceDataBuffer[idx] = data;
        
// //         // Add to filtered buffer for CPU tracking
// //         filteredBuffer.Append(data);
// //     }
// //     else
// //     {
// //         // Still active, add to active buffer for rendering
// //         activeBuffer.Append(data);
// //     }
// // }
// #pragma kernel CSMain
// #pragma kernel CSUpdateArgs

// struct InstanceData
// {
//     float3 position;
//     int active;
// };

// // Buffers
// StructuredBuffer<InstanceData> _ComputeInstanceDataBuffer; // Read-only yap
// AppendStructuredBuffer<InstanceData> activeBuffer;
// AppendStructuredBuffer<InstanceData> filteredBuffer;
// RWStructuredBuffer<uint> argsBuffer;

// // Shader parameters
// float3 playerPos;
// float radius;
// uint maxInstances;

// [numthreads(64,1,1)]
// void CSMain(uint3 id : SV_DispatchThreadID)
// {
//     uint idx = id.x;
//     if (idx >= maxInstances) return;

//     InstanceData data = _ComputeInstanceDataBuffer[idx];
    
//     // Zaten inactive olanları filtreleme
//     if (data.active == 0) 
//     {
//         filteredBuffer.Append(data);
//         return;
//     }

//     // Mesafe kontrolü
//     float3 diff = data.position - playerPos;
//     float distSq = dot(diff, diff);
//     float radiusSq = radius * radius;

//     if (distSq < radiusSq)
//     {
//         // Sadece append buffer'lara yaz, original buffer'ı değiştirme
//         InstanceData erasedData = data;
//         erasedData.active = 0;
//         filteredBuffer.Append(erasedData);
//     }
//     else
//     {
//         activeBuffer.Append(data);
//     }
// }

// [numthreads(1,1,1)]
// void CSUpdateArgs(uint3 id : SV_DispatchThreadID)
// {
//     // Append buffer'ın gerçek eleman sayısını al
//     uint instanceCount = activeBuffer.GetAppendDataCount();
//     argsBuffer[1] = instanceCount;
// }
